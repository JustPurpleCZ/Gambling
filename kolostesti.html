<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wheel of Fate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the application */
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on touch devices when interacting with the wheel */
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .wheel-container {
            position: relative;
            width: 70vw;
            height: 70vw;

            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none; /* Prevents text selection during drag */
        }
        .wheel, .highlight {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            -webkit-user-drag: none; /* Prevents image dragging */
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            /*user-drag: none;*/
        }
        .wheel {
            /* The spinning element */
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); /* Smooths out manual rotation */
        }
        .highlight {
             /* The interactive highlight layer */
            cursor: pointer;
            z-index: 10;
            opacity: 0.5;
        }
        .arrow {
            position: absolute;
            top: -5.1vw; /* Position arrow above the wheel */
            width: 14vw;
            height: 13vw;
            scale: 0.55;
            z-index: 20;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
            /* NEW: Add a transition for smooth snapping back to center */
            transition: transform 0.1s ease-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen overflow-hidden p-4">

    <div class="text-center mb-8">
        <h1 class="text-4xl font-bold tracking-tight">Wheel of Fate</h1>
        <p class="text-gray-400 mt-2">Drag or swipe the wheel to spin!</p>
    </div>

    <div id="wheelContainer" class="wheel-container">
        
        <img src="pointer.png" alt="Pointer" class="arrow">

        <img src="kolo2.png" alt="Spinning Wheel" id="wheel" class="wheel">

        <img src="odlesk3.png" alt="Highlight" id="highlight" class="highlight">

    </div>

    <div id="result" class="mt-8 text-center bg-gray-800 px-6 py-4 rounded-lg shadow-lg">
        <p class="text-lg text-gray-400">The wheel will land on:</p>
        <p id="resultText" class="text-3xl font-bold text-red-400 transition-all duration-300">Spin to find out!</p>
    </div>

   <script>
        // DOM element references
        const wheel = document.getElementById('wheel');
        const highlight = document.getElementById('highlight');
        const wheelContainer = document.getElementById('wheelContainer');
        const resultText = document.getElementById('resultText');
        const arrow = document.querySelector('.arrow');
        const clickSound = new Audio('click.mp3'); 

        // State variables
        let rotation = 0;
        let isDragging = false;
        let angularVelocity = 0;
        const friction = 0.995;
        let startAngle = 0;
        let animationFrameId;

        // --- NEW: State variables for the arrow's "kick" animation ---
        let arrowTilt = 0;
        const arrowDamping = 0.9; // How quickly the arrow settles. Higher is slower (0.0 to 1.0).
        let lastKnownSegment = 0; // Used to detect when a divider is crossed.

        // --- Interaction Logic ---

        function getEventAngle(event) {
            const rect = wheelContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            return Math.atan2(clientY - centerY, clientX - centerX);
        }

        function onDragStart(event) {
            event.preventDefault();
            isDragging = true;
            cancelAnimationFrame(animationFrameId);
            startAngle = getEventAngle(event) - (rotation * Math.PI / 180);
            angularVelocity = 0;
            wheel.style.transition = 'none';
        }

        function onDragMove(event) {
            if (!isDragging) return;
            event.preventDefault();
            const currentEventAngle = getEventAngle(event);
            const newRotationDegrees = (currentEventAngle - startAngle) * (180 / Math.PI);
            const deltaRotation = newRotationDegrees - rotation;
            angularVelocity = deltaRotation;
            rotation = newRotationDegrees;
            wheel.style.transform = `rotate(${rotation}deg)`;
        }

        function onDragEnd(event) {
            if (!isDragging) return;
            isDragging = false;
            wheel.style.transition = '';
            // Reset the segment tracker when a new spin starts
            lastKnownSegment = Math.floor(rotation / 45);
            startFreeSpin();
        }

        // --- Animation Logic ---

        function startFreeSpin() {
            cancelAnimationFrame(animationFrameId);
            
            const spin = () => {
                // Update wheel rotation
                rotation += angularVelocity;
                angularVelocity *= friction;
                wheel.style.transform = `rotate(${rotation}deg)`;
                
                // --- COMPLETELY REVISED ARROW ANIMATION LOGIC ---

                // 1. Check if a divider has been crossed
                const currentSegment = Math.floor(rotation / 45);
                if (currentSegment !== lastKnownSegment) {
                    const speed = Math.abs(angularVelocity);
                    const direction = Math.sign(angularVelocity);
                    
                    // 2. Give the arrow a "kick". The kick is stronger at higher speeds.
                    // This creates a snappy reaction when fast and a gentle nudge when slow.
                    const kickStrength = Math.min(60, 15 + speed * 5); // Capped at 60 degrees
                    
                    // The kick is always against the direction of the wheel's motion.
                    arrowTilt = -direction * kickStrength;
                    clickSound.currentTime = 0;
                    clickSound.play();
                    // 3. Update our tracker
                    lastKnownSegment = currentSegment;
                }
                
                // 4. On every frame, apply damping to make the arrow settle back to center.
                // This creates the smooth "decay" animation.
                arrowTilt *= arrowDamping;
                
                // Apply the final transform to the arrow
                arrow.style.transform = `rotate(${arrowTilt}deg)`;


                // Check if the wheel has stopped
                if (Math.abs(angularVelocity) < 0.05) {
                    cancelAnimationFrame(animationFrameId);
                    arrow.style.transform = 'rotate(0deg)'; // Ensure it's perfectly centered when stopped
                    calculateResult();
                } else {
                    animationFrameId = requestAnimationFrame(spin);
                }
            };
            animationFrameId = requestAnimationFrame(spin);
        }

        // --- Result Calculation ---

        function calculateResult() {
            const finalAngle = (rotation % 360 + 360) % 360;
            const segmentIndex = Math.floor(((finalAngle + 22.5) % 360) / 45);
            const result = 8 - segmentIndex;
            resultText.textContent = `Segment ${result}`;
            resultText.style.transform = 'scale(1.1)';
            setTimeout(() => {
                resultText.style.transform = 'scale(1)';
            }, 300);
        }
        
        // --- Event Listeners ---
        highlight.addEventListener('mousedown', onDragStart);
        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        highlight.addEventListener('touchstart', onDragStart);
        document.addEventListener('touchmove', onDragMove);
        document.addEventListener('touchend', onDragEnd);

    </script>

</body>
</html>