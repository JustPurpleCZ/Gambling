JAVASCRIPT
const nameP = document.getElementById("lobbyName");
nameP.textContent = localStorage.getItem("lobbyName");

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const cup = document.getElementById('cup');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Game state
let dice = [];
let lockedDice = [];
let isDraggingCup = false;
let cupX = window.innerWidth - 150;
let cupY = window.innerHeight - 150;
let mouseX = 0;
let mouseY = 0;
let prevMouseX = 0;
let prevMouseY = 0;
let shakeIntensity = 0;
let cupVelocityX = 0;
let cupVelocityY = 0;
let cupState = 'normal'; // 'normal' or 'spilling'
let isRolling = false;

// Position cup initially
cup.style.left = cupX + 'px';
cup.style.top = cupY + 'px';

// Load images
const cupImg = 'main/dice/cup.png';
const cupSpillImg = 'main/dice/cup_spill.png';
const diceImages = [];
for (let i = 1; i <= 6; i++) {
  diceImages.push(`main/dice/${i}.png`);
}
const lockedOverlay = 'main/dice/locked.png'; // You'll need to add this image

cup.style.backgroundImage = `url(main/dice/cup.png)`;
cup.style.backgroundSize = 'contain';

// Audio context for shake sound
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playShakeSound() {
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  
  oscillator.frequency.value = 100 + Math.random() * 50;
  oscillator.type = 'sine';
  
  gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
  
  oscillator.start(audioCtx.currentTime);
  oscillator.stop(audioCtx.currentTime + 0.1);
}

// Cup dragging
cup.addEventListener('mousedown', (e) => {
  if (isRolling) return;
  
  isDraggingCup = true;
  cup.classList.add('dragging');
  cupState = 'normal';
  cup.style.backgroundImage = `url(${cupImg})`;
  
  const rect = cup.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
  prevMouseX = e.clientX;
  prevMouseY = e.clientY;
  
  e.preventDefault();
});

document.addEventListener('mousemove', (e) => {
  if (!isDraggingCup) return;
  
  cupX = e.clientX - mouseX;
  cupY = e.clientY - mouseY;
  
  cup.style.left = cupX + 'px';
  cup.style.top = cupY + 'px';
  
  // Calculate shake intensity and cup velocity
  const dx = e.clientX - prevMouseX;
  const dy = e.clientY - prevMouseY;
  const speed = Math.sqrt(dx*dx + dy*dy);
  
  // Track cup velocity for dice launch direction
  cupVelocityX = dx * 0.5;
  cupVelocityY = dy * 0.5;
  
  if (speed > 10) {
    shakeIntensity += speed;
    if (shakeIntensity > 50) {
      playShakeSound();
      shakeIntensity = 0;
    }
  } else {
    shakeIntensity *= 0.8;
  }
  
  prevMouseX = e.clientX;
  prevMouseY = e.clientY;
  
  // Check for collecting dice
  collectDice();
});

document.addEventListener('mouseup', () => {
  if (!isDraggingCup) return;
  
  isDraggingCup = false;
  cup.classList.remove('dragging');
  
  // Spill dice if we have unlocked dice to roll
  if (dice.length < 6 - lockedDice.length && cupState === 'normal') {
    spillDice();
  }
});

function spillDice() {
  cupState = 'spilling';
  cup.style.backgroundImage = `url(${cupSpillImg})`;
  
  const numDice = 6 - lockedDice.length;
  
  // Use cup velocity for launch direction, or default forward if no movement
  const launchSpeedMultiplier = 4;
  const baseVx = cupVelocityX !== 0 ? cupVelocityX * launchSpeedMultiplier : 5;
  const baseVy = cupVelocityY !== 0 ? cupVelocityY * launchSpeedMultiplier : 0;
  
  for (let i = 0; i < numDice; i++) {
    const spread = (Math.random() - 0.5) * 50;
    
    dice.push({
      x: cupX + 50,
      y: cupY + 50,
      vx: baseVx + spread,
      vy: baseVy + spread,
      rotation: Math.random() * 360,
      rotationSpeed: (Math.random() - 0.5) * 20,
      face: Math.floor(Math.random() * 6) + 1,
      rolling: true,
      rollTime: 0,
      element: null
    });
  }
  
  dice.forEach(die => {
    const el = document.createElement('div');
    el.className = 'die rolling';
    el.style.left = die.x + 'px';
    el.style.top = die.y + 'px';
    el.style.backgroundImage = `url(${diceImages[die.face - 1]})`;
    el.style.backgroundSize = 'contain';
    el.style.transform = `rotate(${die.rotation}deg)`;
    document.body.appendChild(el);
    die.element = el;
    
    el.addEventListener('click', () => lockDie(die));
  });
  
  isRolling = true;
  
  // Reset cup velocity
  cupVelocityX = 0;
  cupVelocityY = 0;
}

function collectDice() {
  const cupCenterX = cupX + 50;
  const cupCenterY = cupY + 50;
  const collectRadius = 80;
  
  for (let i = dice.length - 1; i >= 0; i--) {
    const die = dice[i];
    if (die.rolling) continue;
    
    const dx = die.x + 30 - cupCenterX;
    const dy = die.y + 30 - cupCenterY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist < collectRadius) {
      if (die.element) {
        die.element.remove();
      }
      dice.splice(i, 1);
    }
  }
}

function lockDie(die) {
  if (die.rolling) return;
  
  const index = dice.indexOf(die);
  if (index === -1) return;
  
  dice.splice(index, 1);
  
  die.element.classList.add('locked');
  
  // Animate to locked area
  const targetX = 30 + (lockedDice.length % 3) * 70;
  const targetY = 30 + Math.floor(lockedDice.length / 3) * 70;
  
  animateToPosition(die.element, targetX, targetY, () => {
    // Add locked overlay
    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundImage = `url(${lockedOverlay})`;
    overlay.style.backgroundSize = 'contain';
    overlay.style.pointerEvents = 'none';
    die.element.appendChild(overlay);
  });
  
  lockedDice.push(die);
}

function animateToPosition(element, targetX, targetY, callback) {
  const startX = parseFloat(element.style.left);
  const startY = parseFloat(element.style.top);
  const duration = 500;
  const startTime = Date.now();
  
  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    
    const currentX = startX + (targetX - startX) * eased;
    const currentY = startY + (targetY - startY) * eased;
    
    element.style.left = currentX + 'px';
    element.style.top = currentY + 'px';
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else if (callback) {
      callback();
    }
  }
  
  animate();
}

function update() {
  let allStopped = true;
  
  dice.forEach(die => {
    if (die.rolling) {
      die.rollTime += 16;
      
      // Apply velocity
      die.x += die.vx;
      die.y += die.vy;
      
      // Apply friction
      die.vx *= 0.92;
      die.vy *= 0.92;
      
      // Wall collision
      if (die.x < 0) {
        die.x = 0;
        die.vx *= -0.6;
      }
      if (die.x > canvas.width - 60) {
        die.x = canvas.width - 60;
        die.vx *= -0.6;
      }
      if (die.y < 0) {
        die.y = 0;
        die.vy *= -0.6;
      }
      if (die.y > canvas.height - 60) {
        die.y = canvas.height - 60;
        die.vy *= -0.6;
        die.vx *= 0.9;
      }
      
      // Dice collision
      dice.forEach(other => {
        if (die === other) return;
        const dx = other.x - die.x;
        const dy = other.y - die.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist < 60 && dist > 0) {
          const nx = dx / dist;
          const ny = dy / dist;
          const overlap = 60 - dist;
          
          die.x -= nx * overlap * 0.5;
          die.y -= ny * overlap * 0.5;
          other.x += nx * overlap * 0.5;
          other.y += ny * overlap * 0.5;
          
          const relVx = die.vx - other.vx;
          const relVy = die.vy - other.vy;
          const impulse = (relVx * nx + relVy * ny) * 1;
          
          die.vx -= impulse * nx;
          die.vy -= impulse * ny;
          other.vx += impulse * nx;
          other.vy += impulse * ny;
        }
      });
      
      // Update rotation
      die.rotation += die.rotationSpeed;
      die.rotationSpeed *= 0.98;
      
      // Random face changes while rolling
      if (Math.random() < 0.1) {
        die.face = Math.floor(Math.random() * 6) + 1;
        if (die.element) {
          die.element.style.backgroundImage = `url(${diceImages[die.face - 1]})`;
        }
      }
      
      // Check if stopped
      const speed = Math.sqrt(die.vx*die.vx + die.vy*die.vy);
      if (speed < 0.1 && die.rollTime > 1000) {
        die.rolling = false;
        die.vx = 0;
        die.vy = 0;
        die.rotationSpeed = 0;
        die.face = Math.floor(Math.random() * 6) + 1;
        if (die.element) {
          die.element.classList.remove('rolling');
          die.element.style.backgroundImage = `url(${diceImages[die.face - 1]})`;
        }
      } else {
        allStopped = false;
      }
      
      // Update element position
      if (die.element) {
        die.element.style.left = die.x + 'px';
        die.element.style.top = die.y + 'px';
        die.element.style.transform = `rotate(${die.rotation}deg)`;
      }
    }
  });
  
  if (allStopped && isRolling) {
    isRolling = false;
  }
  
  requestAnimationFrame(update);
}

update();

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});
window.addEventListener("keydown", (key) => {
    if (key.key === "l") {
        localStorage.removeItem("lobbyName");
        window.location.href = "dices-hub.html";
    }
})

CSS
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  overflow: hidden;
  font-family: Arial, sans-serif;
  background-color: darkslategray;
}

#gameCanvas {
  position: absolute;
  top: 0;
  left: 0;
  cursor: default;
}

.cup {
  position: absolute;
  width: 10vh;
  height: 10vh;
  cursor: grab;
  user-select: none;
  transition: transform 0.1s;
  z-index: 1000;
  background-position: center;
  background-repeat: no-repeat;
}

.cup:active {
  cursor: grabbing;
}

.cup.dragging {
  transform: scale(1.1);
}

.die {
  position: absolute;
  width: 60px;
  height: 60px;
  cursor: pointer;
  user-select: none;
  transition: opacity 0.2s;
}

.die:hover {
  opacity: 0.8;
}

.die.locked {
  cursor: default;
  pointer-events: none;
}

.die.rolling {
  pointer-events: none;
}

.locked-area {
  position: absolute;
  bottom: 20px;
  left: 20px;
  width: 200px;
  min-height: 100px;
  border: 3px dashed rgba(255, 255, 255, 0.5);
  border-radius: 10px;
  padding: 10px;
}

HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dices: GAME</title>
    <link rel="stylesheet" href="dices-game.css">
</head>
<body>
    <p>Lobby name:</p>
    <p id="lobbyName"></p>
    <canvas id="gameCanvas"></canvas>
    <div class="locked-area"></div>
    <div id="cup" class="cup">
    </div>
    <script src="dices-game.js"></script>
</body>
</html>